[ "Adjacent tokens should be seperated by space!", {
  "id" : 1,
  "name" : "inc",
  "category" : "Increment or decrement preferences",
  "codes" : [ "$E ++ ;", "++ $E ;", "$E += 1 ;", "$E = $E1 + 1 ;", "$E = 1 + $E1 ;" ],
  "holders" : [ "$E", "$E1" ],
  "checkers" : [ {
    "class" : "EqualChecker",
    "argsList" : [ [ 3, "$E", "$E1" ], [ 4, "$E", "$E1" ] ]
  } ],
  "handlers" : [ {
    "class" : "ReplicationHandler",
    "argsList" : [ [ 3, "$E", "$E1" ], [ 4, "$E", "$E1" ] ]
  } ]
}, {
  "id" : 2,
  "name" : "dec",
  "category" : "Increment or decrement preferences",
  "codes" : [ "$E -- ;", "-- $E ;", "$E -= 1 ;", "$E = $E1 - 1 ;" ],
  "checkers" : [ {
    "class" : "EqualChecker",
    "argsList" : [ [ 3, "$E", "$E1" ] ]
  } ],
  "handlers" : [ {
    "class" : "ReplicationHandler",
    "argsList" : [ [ 3, "$E", "$E1" ] ]
  } ]
}, {
  "id" : 3,
  "names" : "assignment1",
  "category" : "Assignment statement preferences",
  "codes" : [ "$E = $E1 $HOMO_BOP $E2 ;", "$E $HOMO_BOP_ASSIGN $E2 ;" ],
  "checkers" : [ {
    "class" : "EqualChecker",
    "argsList" : [ [ 0, "$E", "$E1" ] ]
  }, {
    "class" : "NotIntegerChecker",
    "argsList" : [ [ 0, 1, "$E2" ], [ 1, 1, "$E2" ] ]
  } ],
  "handlers" : [ {
    "class" : "ReplicationHandler",
    "argsList" : [ [ 0, "$E", "$E1" ] ]
  }, {
    "class" : "OpOpAssignConvertHandler",
    "argsList" : [ [ 0, 1, "$HOMO_BOP", "$HOMO_BOP_ASSIGN" ], [ 1, 0, "$HOMO_BOP_ASSIGN", "$HOMO_BOP" ] ]
  } ],
  "comment" : "exclude <<,>>,>>>,because they are not single token(they are combinations of LT and GT)."
}, {
  "id" : 4,
  "name" : "nesting if",
  "category" : "Continuous logic and preferences",
  "codes" : [ "if ( $E && $E1 ) $S", "if ( $E ) { if ( $E1 ) $S }" ],
  "handlers" : [ {
    "class" : "WrapCondHandler",
    "argsList" : [ [ 1, 0, "$E", "$E1" ], [ 2, 0, "$E", "$E1" ] ]
  } ]
}, {
  "id" : 5,
  "name" : "cascading if",
  "category" : "Continuous logic or preferences",
  "codes" : [ "if ( $E || $E1 ) $S", "$^ if ( $E ) $S if ( $E1 ) $S1 " ],
  "checkers" : [ {
    "class" : "EqualChecker",
    "argsList" : [ [ 1, "$S", "$S1" ] ]
  } ],
  "handlers" : [ {
    "class" : "ReplicationHandler",
    "argsList" : [ [ 1, "$S", "$S1" ] ]
  } ]
}, {
  "id" : 6,
  "name" : "loop_empty",
  "category" : "Loops",
  "codes" : [ "for ( ; ; ) $S", "while ( true ) $S" ]
}, {
  "id" : 7,
  "name" : "loop1",
  "category" : "Loops",
  "codes" : [ "for ( ; $E ; ) $S", "while ( $E ) $S" ]
}, {
  "id" : 8,
  "name" : "loop2",
  "category" : "Loops",
  "codes" : [ "for ( $EXP_LIST ; $E1 ; ) $S", "$^ $S(expStmt) while ( $E1 ) $S" ],
  "handlers" : [ {
    "class" : "Exp2ExpStmtHandler",
    "argsList" : [ [ 0, 1, "$EXP_LIST", "$S(expStmt)" ] ]
  }, {
    "class" : "ExpStmt2ExpHandler",
    "argsList" : [ [ 1, 0, "$S(expStmt)", "$EXP_LIST" ] ]
  } ]
}, {
  "id" : 9,
  "name" : "loop3",
  "category" : "Loops",
  "codes" : [ "for ( $VAR_DEC ; $E ; ) $S", "$^ $VAR_DEC ; for ( ; $E ; ) $S","$^ $VAR_DEC ; while ( $E ) $S" ],
  "handlers" : [ {
    "class" : "ConflictNameHandler",
    "argsList" : [ [ 0, 1, "$VAR_DEC", 1], [ 0, 2, "$VAR_DEC", 1] ]
  },{
    "class": "VarUndefExceptionHandler",
    "argsList" : [ [ 1, 0, "$VAR_DEC", "$E" ], [ 2, 0, "$VAR_DEC", "$E" ] ]
  }]
}, {
  "id" : 10,
  "name" : "loop4",
  "category" : "Loops",
  "codes" : [ "for ( ; $E1 ; $EXP_LIST ) { $S* }", "while ( $E1 ) { $S* $S(expStmt) }" ],
  "checker" : [ {
    "class": "VarUpdateStmtChecker",
    "argsList" : [ [ 1, "$S(expStmt)"] ]
  } ],
  "handlers" : [ {
    "class" : "Exp2ExpStmtHandler",
    "argsList" : [ [ 0, 1, "$EXP_LIST", "$S(expStmt)" ] ]
  }, {
    "class" : "ExpStmt2ExpHandler",
    "argsList" : [ [ 1, 0, "$S(expStmt)", "$EXP_LIST" ] ]
  } ]
}, {
  "id" : 11,
  "name" : "loop5",
  "category" : "Loops",
  "codes" : [ "for ( $EXP_LIST ; $E1 ; $EXP_LIST1 ) { $S* }", "$^ $S(expStmt) while ( $E1 ) { $S* $S1(expStmt) }" ],
  "checker" : [ {
    "class": "VarUpdateStmtChecker",
    "argsList" : [ [ 1, "$S1(expStmt)"] ]
  } ],
  "handlers" : [ {
    "class" : "Exp2ExpStmtHandler",
    "argsList" : [ [ 0, 1, "$EXP_LIST", "$S(expStmt)" ] ]
  }, {
    "class" : "ExpStmt2ExpHandler",
    "argsList" : [ [ 1, 0, "$S(expStmt)", "$EXP_LIST" ] ]
  } ]
}, {
  "id" : 12,
  "name" : "loop4",
  "category" : "Loops",
  "codes" : [ "for ( $VAR_DEC ; $E1 ; $EXP_LIST ) { $S* }", "$^ $VAR_DEC ; for ( ; $E1 ; $EXP_LIST ) { $S* }", "$^ $VAR_DEC ; while ( $E1 ) { $S* $S(expStmt) }" ],
  "checkers" : [ {
    "class": "VarUpdateStmtChecker",
    "argsList" : [ [ 1, "$S(expStmt)"] ]
  } ],
  "handlers" : [  {
    "class" : "ConflictNameHandler",
    "argsList" : [ [ 0, 1, "$VAR_DEC", 1 ] , [ 0, 2, "$VAR_DEC", 1]]
  }, {
    "class": "VarUndefExceptionHandler",
    "argsList" : [ [ 1, 0, "$VAR_DEC", "$E1" ], [ 2, 0, "$VAR_DEC", "$E1" ] ]
  },{
    "class" : "Exp2ExpStmtHandler",
    "argsList" : [ [ 0, 2, "$EXP_LIST", "$S(expStmt)" ],[ 1, 2, "$EXP_LIST", "$S(expStmt)" ] ]
  }, {
    "class" : "ExpStmt2ExpHandler",
    "argsList" : [ [ 2, 0, "$S(expStmt)", "$EXP_LIST" ], [ 2, 1, "$S(expStmt)", "$EXP_LIST" ] ]
  } ]
}, {
  "id" : 13,
  "name" : "check_then_return",
  "category" : "Check then return preferences",
  "codes" : [ "return $E ? $E1 : $E2 ;", "if ( $E ) { return $E1 ; } else { return $E2 ; }" ]
}, {
  "id" : 14,
  "name" : "dec_then_check_assign",
  "category" : "Check then assign preferences",
  "codes" : [ "$^ $M $T $I = $E2 ; if ( $E ) { $E3 = $E1 ; }", "$M $T $I = $E ? $E1 : $E2 ;", "$^ $M $T $I ; $E3 = $E ? $E1 : $E2 ;", "$^ $M $T $I ; if ( $E ) { $E3 = $E1 ; } else { $E4 = $E2 ; }" ],
  "checkers" : [ {
    "class" : "EqualChecker",
    "argsList" : [ [ 0, "$I", "$E3" ], [ 2, "$I", "$E3" ], [ 3, "$I", "$E3", "$E4" ] ]
  } ],
  "handlers" : [
    {
      "class": "DecThenAssignExceptionHandler",
      "argsList": [[0, 1, "$I", "$E", "$E1", "$E2"], [2, 1, "$I", "$E", "$E1", "$E2"], [3, 1, "$I", "$E", "$E1", "$E2"]]
    },{
    "class" : "ReplicationHandler",
    "argsList" : [ [ 0, "$I", "$E3" ], [ 2, "$I", "$E3" ], [ 3, "$I", "$E3", "$E4" ] ]
  } ]
}, {
  "id" : 15,
  "name" : "check_then_assign",
  "category" : "Check then assign preferences",
  "codes" : [ "$E = $E1 ? $E2 : $E3 ;", "if ( $E1 ) { $E = $E2 ; } else { $E4 = $E3 ; }" ],
  "checkers" : [ {
    "class" : "EqualChecker",
    "argsList" : [ [ 1, "$E", "$E4" ] ]
  } ],
  "handlers" : [ {
    "class" : "ReplicationHandler",
    "argsList" : [ [ 1, "$E", "$E4" ] ]
  } ]
}, {
  "id" : 16,
  "category" : "Operator preferences",
  "codes" : [ "$E < $E1", "$E1 > $E" ],
  "checkers" : [ ],
  "handlers" : [ ]
}, {
  "id" : 17,
  "category" : "Operator preferences",
  "codes" : [ "$E <= $E1", "$E1 >= $E" ],
  "checkers" : [ ],
  "handlers" : [ ]
}, {
  "id" : 18,
  "category" : "Operator preferences",
  "codes" : [ "$E == false", "! $E" ],
  "checkers" : [ ],
  "handlers" : [ ]
}, {
  "id" : 19,
  "category" : "Literal position in bool expression",
  "codes" : [ "$LITERAL == $E", "$E == $LITERAL" ],
  "checkers" : [ ],
  "handlers" : [ ]
}, {
  "id" : 20,
  "category" : "Array declaration style",
  "codes" : [ "$M $T [] $I ;", "$M $T $I [] ;" ]
}, {
  "id" : 21,
  "category" : "Array declaration style",
  "codes" : [ "$M $T [] $I = $ARRAY_INITIALIZER ;", "$M $T $I [] = $ARRAY_INITIALIZER ;" ]
}, {
  "id" : 22,
  "category" : "Continue preferences",
  "codes" : [ "$^ if ( $E ) { continue ; }  $S+", "if ( $E ) { continue ; } else { $S+ }", "if ( $E ) { $S+ }" ],
  "checkers" : [ {
    "class" : "ContinuePreferenceChecker",
    "argsList" : [ [ 0, "$S+" ], [ 1, "$E" ], [ 2, "$E" ] ]
  } ],
  "handlers" : [ {
    "class" : "CondReverserHandler",
    "argsList" : [ [ 0, 2, "$E" ], [ 1, 2, "$E" ], [ 2, 0, "$E" ], [ 2, 1, "$E" ] ]
  } ,
    {
      "class" : "BraceWrapHandler",
      "argsList" : [ [ 1, 0, "$E", "LOOP"],[ 2, 0, "$E", "LOOP"]]
    }]
}, {
  "id" : 23,
  "category" : "Continue preferences",
  "codes" : [ "$^ if ( $E ) { $S+ continue ; }  $S1+", "if ( $E ) { $S+ continue ; } else { $S1+ }", "if ( $E ) { $S+ } else { $S1+ }" ],
  "checkers" : [ {
    "class" : "ContinuePreferenceChecker",
    "argsList" : [ [ 0, "$S1+" ], [ 1, "$E" ], [ 2, "$E" ] ]
  }, {
    "class" : "UnreachableCauseChecker",
    "argsList" : [ [ 2, "$S+" ] ]
  } ],
  "handlers" : [
    {
      "class" : "BraceWrapHandler",
      "argsList" : [ [ 1, 0, "$E", "LOOP"],[ 2, 0, "$E", "LOOP"]]
    }]
}, {
  "id" : 24,
  "category" : "Redundant code",
  "codes" : [ "$^ if ( $E ) { $S+ }  $S1+", "if ( $E ) { $S+ } else { $S1+ }" ],
  "checkers" : [ {
    "class" : "UnreachableCauseChecker",
    "argsList" : [ [ 0, "$S+" ], [ 1, "$S+" ]]
  }, {
    "class" : "EndsWithChecker",
    "argsList" : [ [ 1, "$S+", "$S1+" ] ]
  }, {
    "class" : "StmtComplexityChecker",
    "argsList" : [ [ 0, "$S1+", 3, "SINGLE_STMT" ], [ 1, "$S1+", 3, "SINGLE_STMT" ] ]
  } ],
  "handlers" : [ {
    "class" : "AppendTreeHandler",
    "argsList" : [ [ 0, 1, "$S+", "$S1+" ] ]
  } ],
  "comments" : "Consider to add complexity checker to check the complexity of '$S1+'"
} , {
  "id" : 25,
  "category" : "Redundant code",
  "codes" : [ "$^ if ( $E ) { $S+ } else { $S1+ } $S2+", "if ( $E ) { $S+ } else { $S1+ }" ],
  "checkers" : [ {
    "class" : "UnreachableCauseChecker",
    "argsList" : [ [ 0, "$S+", "$S1+" ], [ 1, "$S+", "$S1+" ]]
  }, {
    "class" : "HasSameEndingStmtChecker",
    "argsList" : [ [ 1, "$S+", "$S1+" ] ]
  }, {
    "class" : "StmtComplexityChecker",
    "argsList" : [ [ 0, "$S2+", 3, "SINGLE_STMT" ], [ 1, "$S2+", 3, "SINGLE_STMT" ] ]
  } ],
  "handlers" : [ {
    "class" : "AppendTreeHandler",
    "argsList" : [ [ 0, 1, "$S+", "$S2+" ],[ 0, 1, "$S1+", "$S2+" ] ]
  },{
    "class": "RedundantCodeHandler",
    "argsList" : [[1, 0, "$S+", "$S1+", "$S2+"]]
  }],
  "comments" : "Consider to add complexity checker to check the complexity of '$S1+'"
}]